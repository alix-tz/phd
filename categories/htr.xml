<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="https://alix-tz.github.io/phd/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>A research (b)log (Posts about HTR)</title><link>https://alix-tz.github.io/phd/</link><description></description><atom:link href="https://alix-tz.github.io/phd/categories/htr.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents ¬© 2023 &lt;a href="https://alix-tz.github.io/phd/"&gt;Alix Chagu√©&lt;/a&gt; CC-BY</copyright><lastBuildDate>Sat, 15 Jul 2023 17:12:26 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>012 - "It did a very good job"</title><link>https://alix-tz.github.io/phd/posts/012/</link><dc:creator>Alix Chagu√©</dc:creator><description>&lt;p&gt;A few weeks ago, I attended the presentation of an automatic transcription software. The majority of the audience was unfamiliar with the concept of handwritten text recognition (HTR) or had little experience using it. The presentation lasted only an hour, so it couldn't delve into much detail. Its main objective was to demonstrate the software's results. The presenter shows several slides, displaying on one side  images of manuscripts (often in a language unknown to the audience) and on the other side the transcriptions generated by the software. Throughout the presentation, the presenter repeatedly commented on the HTR software saying that "it did a very good job."&lt;/p&gt;
&lt;p&gt;But what does it even mean?&lt;/p&gt;
&lt;p&gt;The very first aspect to explore is what distinguishes a good job from a bad one. Normally, such an evaluation relies on the measurement of the accuracy of the result compared to the ideal transcription. The accuracy can be expressed positively or negatively using the error rates (a 0% error rates is the same as a 100% accuracy).&lt;/p&gt;
&lt;p&gt;Measuring the accuracy of a prediction (another way to call the result of HTR) is commonly done at character level. The character accuracy of a model is equal to the number of matches between the prediction and the ideal transcription. The character error rate (CER) is a very common measure to express a model's theoretical efficiency.&lt;/p&gt;
&lt;p&gt;Sometimes softwares also consider the word error rate (WER), which the proportion of words in the prediction containing no error. A high score at WER doesn't actually mean that the transcription is bad. It only means that the errors are distributed on all the words. I never use WER alone because it is hard to get an exact impression of the quality of the prediction based on that metric alone.&lt;/p&gt;
&lt;p&gt;There is a paper from &lt;a href="https://dl.acm.org/doi/10.1145/3476887.3476888"&gt;Neudecker et al. (2021)&lt;/a&gt; where they test 5 different software used for evaluating the prediction. They also develop an interesting reflection on alternative metrics such as the "non-stopword accuracy", the "phrase accuracy", the "flexible character accuracy" (which is useful when the line order isn't always the same), the "figure of merit" (which "aims to quantify the effort required for manual post-correction" (p. 15)) or else the "unordered WER".&lt;/p&gt;
&lt;p&gt;When your score is a rate, there is an implicit idea that 100% is both the maximum score and the targeted score (for accuracy of course). But in the case of HTR, 100% accuracy is extremely rare because there are also edge cases where the way a letter was drawn is ambiguous: in such cases the error is not particularly caused by the inaccuracy of the software but rather by the imperfection of the handwriting in the first place.&lt;/p&gt;
&lt;p&gt;In &lt;a href="https://openhumanitiesdata.metajnl.com/articles/10.5334/johd.46"&gt;Hodel et al., (2021)&lt;/a&gt;, the authors provided a grid to interpret accuracy scores. They suggest the following three threshold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CER &amp;lt; 10% == good (it allows efficient post-processing)&lt;/li&gt;
&lt;li&gt;CER &amp;lt; 5% == very good (errors are usually focused on rare or unknown words)&lt;/li&gt;
&lt;li&gt;CER &amp;lt; 2.5% == excellent (but it is usually only reached when the handwriting is very regular)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Personally, I think this grid should also include 20% and 0%. 20% as a threshold, because at 80% of accuracy, the transcription is supposedly good enough for fuzzy search and keyword spotting; and 0% because it should be reminded that an accuracy of 100% is virtually impossible.&lt;/p&gt;
&lt;p&gt;To complement this, I would like to mention another possible approach to get an interpretable score: during the DH2023, Thibault Cl√©rice and I &lt;a href="https://inria.hal.science/hal-04094241"&gt;presented an experiment&lt;/a&gt; where we trained a model using the same data in the train set and the test set. Our model reached an accuracy close to 90%, which we were able to use as a baseline to define the highest accuracy score possible for the data we had. Thus we were able to consider that a model approaching 90% of accuracy would be an excellent model, as far as that dataset was concerned.&lt;/p&gt;
&lt;p&gt;During &lt;a href="https://www.conftool.pro/dh2023/index.php?page=browseSessions&amp;amp;form_session=76#paperID395"&gt;the DH2023 conference&lt;/a&gt;, Wouter Haverals presented &lt;a href="https://github.com/WHaverals/CERberus"&gt;CERberus üê∂üê∂üê∂&lt;/a&gt;, a web interface which addresses the same type of issues as &lt;a href="https://huggingface.co/spaces/lterriel/kami-app"&gt;KaMI&lt;/a&gt;: the lack of nuance in a plain CER computation. Indeed, in a CER score, every type of error has the same weight. This means that mistaking an "e" for a "√©" costs the same as mistaking a "e" for a "0": in the first case the text is likely still readable or understandable, whereas in the latter, it might not be the case.&lt;/p&gt;
&lt;p&gt;The CER metric is still very useful, but it even more so when we can filter the types of errors we want to include in the evaluation.&lt;/p&gt;
&lt;p&gt;So, to go back to our initial problem, we can see that there are many ways to draw the line between a good job and a bad one. The threshold will depend on the metric used to express the accuracy of the prediction and also (and mostly) on the way the generated text will be used down the line. Even though the software presentation I attended was short, I think we should always remind future users of HTR that 100% of accuracy is not always what they are seeking.&lt;/p&gt;
&lt;p&gt;A short reflection to finish this post: I was bothered by the expression used to qualify the transcription and I am still trying to figure out a way to put it into words. On top of lacking accuracy, this expression was also calling for a vision of HTR as a magic tool at the service of the searchers and students. But, in which other cases do you say that someone did "a good job?" Likely when you delegate a task to a subaltern.&lt;/p&gt;
&lt;p&gt;I see a problem here: in their current state, HTR engines are efficient but not to the point that people can use them without thinking clearly about what they want the engine to produce. It is easy to sell a software pretending that it is a magic servant that will do all the transcription in your place, a tool so smart that you can even consider delegating a part of your responsibility. But I think when new users of HTR fail to first reflect on the outcome they can reasonably expect from these engines, it actually creates disappointment and crappy data and workflows.&lt;/p&gt;</description><category>accuracy</category><category>evaluation</category><category>HTR</category><category>metrics</category><guid>https://alix-tz.github.io/phd/posts/012/</guid><pubDate>Sat, 15 Jul 2023 12:06:20 GMT</pubDate></item><item><title>011 - Working with synthetic data</title><link>https://alix-tz.github.io/phd/posts/011/</link><dc:creator>Alix Chagu√©</dc:creator><description>&lt;p&gt;What we call synthetic data are data generated artificially, as opposed to data taken from real-life samples. In the case of automatic transcription or layout analysis, it corresponds to creating fake documents or samples of text that look more or less like real ones, in stead of manually annotating existing documents.&lt;/p&gt;
&lt;p&gt;One of the main advantages of using synthetic data rather than real data is the fact that it comes already annotated. For automatic transcription for example, the annotation (transcription) is the same as the string of text passed to a text image generator. If you add to that the fact you can, in theory, generate an unlimited amount of pairs of text image and transcription, it represents an incredible opportunity to accelerate the production of training datasets. An example: &lt;a href="https://ieeexplore.ieee.org/document/8486162"&gt;Doush et al., 2018&lt;/a&gt; use this technique to generate PDF containing contemporary printed Arabic texts. The PDFs are printed, then re-scanned and aligned with the transcription that was used to generate the PDFs. The result is the Yarmouk dataset. As we will see later, generating fake handwritten text is a bit more difficult.&lt;/p&gt;
&lt;p&gt;Another advantage of this technique is that it offers an efficient way around the limitations posed by sensitive or confidential data (&lt;a href="https://doi.org/10.1007/978-3-319-11257-2_15"&gt;Hu et al. 2014&lt;/a&gt;). However, let's note that confidentiality is rarely a problem when it comes to training HTR models on historical documents.&lt;/p&gt;
&lt;p&gt;Generating fake data is not specific to computer vision (&lt;a href="https://www.annualreviews.org/doi/10.1146/annurev-statistics-040720-031848"&gt;Raghunathan, 2021&lt;/a&gt;), even though it is frequently used in this case because data for computer vision tasks are costly to produce. In general, it is a fairly frequent method when machine learning techniques are involved, disregarding the field of application (&lt;a href="https://link.springer.com/article/10.1007/s11263-021-01555-8"&gt;Kataoka et al., 2022&lt;/a&gt;). OCR and HTR tasks are not an exception and we can find traces of such experiments rather early (&lt;a href="https://ieeexplore.ieee.org/document/4669952"&gt;Beusekom et al., 2008&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The first time I was exposed to the notion of synthetic data was during a informal conversation with &lt;a href="https://www.tmonnier.com/"&gt;Tom Monnier&lt;/a&gt; in 2019. At that time, he was working on &lt;a href="https://arxiv.org/abs/2012.08191"&gt;docExtractor&lt;/a&gt;, a layout analysis tool that he trained with images of documents generated artificially.&lt;sup id="fnref:icfhr"&gt;&lt;a class="footnote-ref" href="https://alix-tz.github.io/phd/posts/011/#fn:icfhr"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Then sometimes in 2021, while browsing through &lt;a href="https://huggingface.co/spaces/launch"&gt;HuggingFace's spaces&lt;/a&gt;, I found ntt123's application that simulates &lt;a href="https://huggingface.co/spaces/ntt123/handwriting"&gt;handwriting&lt;/a&gt;. The application takes a text prompt as an input and generates an animation where the letters are traced on the page as if someone was writing them live. It's possible to play with two parameters: a value between 0 and 250 determining the writing style, and a weight determining the likelihood of the traced letters (the lower the weight, the higher the risk of &lt;a href="https://en.wikipedia.org/wiki/Hallucination_(artificial_intelligence)"&gt;hallucinated&lt;/a&gt; letters; the higher the weight, the more standardized the tracing). It made me think back to my conversation with Tom Monnier and I wondered if it could be used to generate pairs of text and images.&lt;/p&gt;
&lt;p&gt;At the beginning of the year, I dedicated a good part of my time to testing data generation tools I could find online, to see if they could be used to create a set of fake ground truth that I would use later, in other experiments. I will introduce the latter in a future post, so let's first focus on handwritten data generation.&lt;/p&gt;
&lt;p&gt;When I dug a bit more around ntt123's application, I was confronted with two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;unfortunately, ntt123's application was developed in javascript and not documented at all which made it impossible for me to hack,&lt;/li&gt;
&lt;li&gt;but luckily, it wasn't an original idea: instead it was one of many implementations of a proposition introduced by &lt;a href="http://arxiv.org/abs/1308.0850"&gt;Alex Graves in 2014&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Alex Graves uses online&lt;sup id="fnref:online"&gt;&lt;a class="footnote-ref" href="https://alix-tz.github.io/phd/posts/011/#fn:online"&gt;2&lt;/a&gt;&lt;/sup&gt; data from the IAM database (&lt;a href="https://ieeexplore.ieee.org/document/1575685"&gt;Liwicki &amp;amp; Bunke, 2005&lt;/a&gt;) and an &lt;a href="https://en.wikipedia.org/wiki/Long_short-term_memory"&gt;LSTM (Long Short-Term Memory)&lt;/a&gt; to train a model capable of generating series of coordinates that trace letters and words. Initially, the model simply generates random series of letters and words, but it is then improved to take into account a text prompt which forces the models to generate a specific series of letters. As described before, the model also takes a weight (or bias) which normalizes the likelihood of the letters' shape, and can take a "priming line": the image of a handwritten line, whose writing style the model will try to copy. Once the coordinates are generated (including key information such as "ends-of-stroke"), it is easy to place them in an SVG file and visualize the result, with or without animation.&lt;/p&gt;
&lt;p&gt;There are many many implementations of Alex Graves's experiment because it was such an important publication to demonstrate the usefulness of LSTM models. Several can be found on Github if you &lt;a href="https://github.com/search?q=alex%20graves&amp;amp;type=repositories"&gt;search "Alex Graves"&lt;/a&gt;. For my experiment, I didn't want to develop my own adaptation of such a model, but rather to use programs that were ready to be used. This is the reason why I didn't look for papers but instead for recent (or recently updated) repositories on Github. I focused on Python programs because I wanted to be able to understand how they were developed.&lt;/p&gt;
&lt;p&gt;One very promising implementation of Alex Graves' proposition was Evgenii Dolotov's &lt;a href="https://github.com/X-rayLaser/pytorch-handwriting-synthesis-toolkit"&gt;pytorch-handwriting-synthesis-toolkit&lt;/a&gt;. It came with pre-trained models, and a utility scripts to feed the program a text prompt and generate an image. I &lt;a href="https://github.com/alix-tz/pytorch-handwriting-synthesis-toolkit/tree/custom"&gt;customized&lt;/a&gt;&lt;sup id="fnref:customization"&gt;&lt;a class="footnote-ref" href="https://alix-tz.github.io/phd/posts/011/#fn:customization"&gt;3&lt;/a&gt;&lt;/sup&gt; the program a bit to fix a few bugs and try to make it generate several lines maintaining the same handwriting.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alix-tz.github.io/phd/images/PHST_fail_and_success.png" alt="4 lines stating (or supposed to state) 'did a computer write this' generated by Evgenii Dolotov's program. The fourth line is a failed attempt where several letters like y, n, m can be dinstiguished. The fifth line states 'determined to act upon the assumptions' but contains several garbled letters." widht="600px"&gt;&lt;/p&gt;
&lt;p&gt;Even though the generated images were sometimes impressively realistic, it created a lot of bad output. As suggested by Alex Graves, his solution tends to generate what he calls "garbled letters", letters that no human would likely trace. In other cases, it would randomly skip some letters and be completely incapable of tracing some numbers or punctuation signs. Sometimes, the model would simply draw more or less flat lines. Since I wanted to generate fake &lt;em&gt;gold&lt;/em&gt; data that I could trust and since the results were not reliable enough, I played with the bias and the priming lines before trying to train new models using Evgennii Dolotov's utility scripts. I failed to get better results than the pre-trained models, and failed to find the correct parameters to make sure I would obtain always realistic output.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alix-tz.github.io/phd/images/PHST_fail_multiline.png" alt="several flat lines that at one point successfully write 'is fin'. This is a failed generated image." width="100px"&gt;&lt;/p&gt;
&lt;!-- change image to add more examples --&gt;

&lt;p&gt;At this point I started exploring &lt;a href="https://en.wikipedia.org/wiki/Generative_adversarial_network"&gt;GANs (Generative Adversarial Networks)&lt;/a&gt; which are models based on game theory. They are capable of generating realistic fake images learning from samples of real images (see &lt;a href="https://doi.org/10.1145/3422622"&gt;Goodfellow et al., 2020&lt;/a&gt;). They are this kind of models used to generate photos of &lt;a href="https://this-person-does-not-exist.com/en"&gt;people who don't exist&lt;/a&gt;. There are Github repositories offering source code to train such models to generate fake handwriting, such as &lt;a href="https://github.com/omni-us/research-GANwriting"&gt;GANwriting&lt;/a&gt; (described in &lt;a href="http://arxiv.org/abs/2003.02567"&gt;Kang et al., 2020&lt;/a&gt;) or Amazon's &lt;a href="https://github.com/amzn/convolutional-handwriting-gan"&gt;ScrabbleGAN&lt;/a&gt; (introduced in &lt;a href="https://openaccess.thecvf.com/content_CVPR_2020/html/Fogel_ScrabbleGAN_Semi-Supervised_Varying_Length_Handwritten_Text_Generation_CVPR_2020_paper.html"&gt;Fogel et al., 2020&lt;/a&gt;) but they were only giving instructions to reproduce the corresponding papers and train the models ourselves. Since GANs are costly to train, I left this option out for the moment, even though I do think they can become an interesting solution in the future.&lt;/p&gt;
&lt;p&gt;Eventually, I settled for a solution based on a &lt;a href="https://en.wikipedia.org/wiki/Diffusion_model"&gt;Diffusion model&lt;/a&gt;. This type of model can be found behind applications like &lt;a href="https://openai.com/product/dall-e-2"&gt;OpenAI's DALL-E&lt;/a&gt;. Luhman &amp;amp; Luhman (2020), who created the &lt;a href="https://github.com/tcl9876/Diffusion-Handwriting-Generation"&gt;Diffusion Handwriting Generation&lt;/a&gt; (later called DHG), explain very well how diffusion models work.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Diffusion probabilistic models [...] convert a known distribution (e.g. Gaussian) into a more complex data distribution. A diffusion process converts the data distribution into a simple distribution by iteratively adding Gaussian noise to the data, and the generative model learns to reverse this diffusion process." (Luhman &amp;amp; Luhman, 2020, p. 1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A great advantage with DHG compared to the LSTM approach was that it was possible to easily fix the priming line and almost always obtain a convincing output. This was essential to create a dataset with a consistent handwriting over hundred of lines. As visible in the following image, even if the diffusion model is not capable of perfectly imitating the handwriting contained in the priming line, it usually successfully captures elements of style such as the slant, or the cursive nature of the text.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alix-tz.github.io/phd/images/DHG_generated.png" alt="five pairs of priming lines with the resulting generated lines." width="800px"&gt;&lt;/p&gt;
&lt;p&gt;After several tests, I found that the third priming line gave the best results when associated with different text prompts, so I decided to use it along with excerpts from &lt;a href="https://www.gutenberg.org/files/2701/2701-0.txt"&gt;Moby Dick&lt;/a&gt; to create a completely artificially generated dataset. In a few days, I created more than 8,000 images (PNG) associated with a text file (TXT) containing the prompts used to generate them.&lt;/p&gt;
&lt;p&gt;These pairs could have been used "as is" to produce a silver synthetic dataset but, like I said before, I needed a gold dataset where the text and the images would be exact matches. Unfortunately, more than a third of the images did not qualify as gold. After manually reviewing about 2,500 of the lines (with the help of my colleague Hugo Scheithauer), we published a set of 1,280 pairs of lines and text under the name "&lt;a href="https://github.com/alix-tz/spinnerbait"&gt;Spinnerbait&lt;/a&gt;".&lt;/p&gt;
&lt;p&gt;Even though I was able to produce a dataset meeting my main criteria, I was actually disappointed with my results: I wanted a sort of magic button which would allow me to generate, at any time and without having to review it, a perfect set of training data. Instead, in the future, if I want to add more lines to Spinnerbait, I will have to spend a few hours going through each line to filter the bad ones out.&lt;/p&gt;
&lt;p&gt;On the other hand, I decided to take a few hours to manually copy a text taken from Guillaume Apollinaire's poems. I copied the text following a txt file that I would edit every time I would start a new line, I scanned it, segmented it with eScriptorium before copying and pasting the lines from the txt file and exported the result as a series of XML ALTO and images. It gave birth to the &lt;a href="https://github.com/alix-tz/moonshines"&gt;Moonshines&lt;/a&gt; dataset, a set of 1,186 lines (including 170 dedicated to a fixed test subset) of a single hand, thus comparable in size to Spinnerbaits.&lt;/p&gt;
&lt;p&gt;I think generating both datasets took about the same amount of time, if I take into account on the one hand reviewing the generated lines and on the other hand copying the text and passing it through eScriptorium. Moonshines used less computing resources and produced a richer dataset if we consider the aspect of the text. Also, the length of the lines is more varied in Moonshines whereas it is more homogenous (max 5 words) in Spinnerbait, because the generator tended to make more errors on longer prompts.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://alix-tz.github.io/phd/images/spinnerbait_moonshines.png" alt="a line taken from the Spinnerbait dataset and a line taken from the Moonshines dataset" widht="600px"&gt;&lt;/p&gt;
&lt;p&gt;Another important limitation that I have barely addressed at this point it that not only do these tools fail to draw non-ASCII characters, but they also tend to have a greater chance of producing garbled letters when prompted with rare or non-english words&lt;sup id="fnref:iam"&gt;&lt;a class="footnote-ref" href="https://alix-tz.github.io/phd/posts/011/#fn:iam"&gt;4&lt;/a&gt;&lt;/sup&gt;. This is true of all the systems I have tested. Of course, we could imagine training new models on data containing a greater diversity of languages, or simply other scripts or languages.&lt;/p&gt;
&lt;p&gt;As way of a conclusion, I would say that even though I was disappointed with what I obtained down the line, this exploratory adventure was very interesting. I learned a lot and I am convinced that if I had more time and resources (and if it were more crucial for me), I would have found a way to get better results. I know of some coming publications that used GANs to create artificial data that look like lines taken from historical documents and I really look forward reading them.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:icfhr"&gt;
&lt;p&gt;It is possible to find &lt;a href="https://youtu.be/Tuw8uQonW7E?t=145"&gt;here&lt;/a&gt; a recording of the talk given on this tool at ICFHR 2020.¬†&lt;a class="footnote-backref" href="https://alix-tz.github.io/phd/posts/011/#fnref:icfhr" title="Jump back to footnote 1 in the text"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:online"&gt;
&lt;p&gt;In the context of handwritten text recognition, a distinction is made between "online" data and "offline" data. Offline data are based on a matrix of pixels containing the image of a text (they are static), whereas online data are vectors containing information about the speed, the points through which a line passes to form a letter, end of stroke points, etc. Online HTR uses data generated with an e-pen and a screen while offline HTR uses images created with a scanner or a camera.¬†&lt;a class="footnote-backref" href="https://alix-tz.github.io/phd/posts/011/#fnref:online" title="Jump back to footnote 2 in the text"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:customization"&gt;
&lt;p&gt;One of the customizations consisted in removing non-ASCII characters or characters not supported by the model. It was easy to apply this transformation because in pytorch-handwriting-synthesis-toolkit, each model comes with a little metadata file which contains the character set handled by the model.¬†&lt;a class="footnote-backref" href="https://alix-tz.github.io/phd/posts/011/#fnref:customization" title="Jump back to footnote 3 in the text"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:iam"&gt;
&lt;p&gt;All the models were trained using the IAM database, more often the "online" database, but sometimes also with the "offline" version.¬†&lt;a class="footnote-backref" href="https://alix-tz.github.io/phd/posts/011/#fnref:iam" title="Jump back to footnote 4 in the text"&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><category>experiment</category><category>HTR</category><category>synthetic data</category><guid>https://alix-tz.github.io/phd/posts/011/</guid><pubDate>Sun, 21 May 2023 18:12:26 GMT</pubDate></item></channel></rss>